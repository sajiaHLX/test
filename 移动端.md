### 一、HTML5（H5）
**1.新增加(修改/删除)的语义化标签**
  header
  footer
  main 主体
  section 区域
  article 文章区域
  aside 与内容无关的部分（例如：广告）
  nav
  figure 配图区域
  figcaption 配图说明

  mark 标记
  time 时间标记
  progress 进度条
  ...

**2.关于表单元素的新改革**
 [传统表单元素]
    input:text/password/radio/checkbox/file/hidden/button/submit/reset...
    select
    textarea 文本域
    button
    form
    label
    ...

 [新增一些表单元素或者是表单类型]
    input:search/email/tel/number/range/color/date/time/url...

**3.音视频标签**
  audio

​	 关于AUDIO的一些常用属性

​     [属性]

​     duration:播放的总时间(S)

​     currentTime:当前已经播放的时间(S)

​     ended:是否已经播放完成

​     paused:当前是否为暂停状态

​    volume:控制音量 (0~1)

 

​     [方法]

​     pause() 暂停

​     play() 播放

 

​     [事件]

​     canplay：可以正常播放（但是播放过程中可能出现卡顿）

   canplaythrough：资源加载完毕，可以顺畅的播放了

​     ended：播放完成

​     loadedmetadata：资源的基础信息已经加载完成

​     loadeddata：整个资源都加载完成

​     pause:触发了暂停

​     play:触发了播放

​     playing:正在播放中

  video
  =>让我们告别了FLASH时代

**4.canvas图形绘制**

**5.提供了一些新的API**
  本地存储：localStorage/sessionStorge
  获取地理位置： navigator.geolocation.getCurrentPosition 调取手机内部的GPS定位系统获取当前手机所在地的经纬度以及精准度等
  ...
  还提供了一些API，让我们可以通过浏览器调取手机内部的软件或者硬件（但是性能都不咋高，而且兼容性不是特别好）

6.websocket：socket.io 客户端和服务器端新的传输方式（即时通讯IM系统基本上很多是基于它完成的）

...



### 二、CSS3
  学习一些样式属性和选择器就差不多了

  [选择器]
    #ID
    .CLASS
    TAG
    *
    SELECTOR1,SELECTOR1... 群组选择器

```
A .B{} 后代
A.B{} 既具备A也具备.B的（同级二次筛选）
A>B{} 子代
A+B{} 下一个弟弟
A~B{} 兄弟

A[NAME=''] 属性选择器 NAME!='' / NAME^='' / NAME$='' / NAME*='' ...

A:HOVER
A:ACTIVE
A:VISTED
A:AFTER
A:BEFORE

A:NTH-CHILD
A:NTH-LAST-CHILD
A:NTH-OF-TYPE
A:NTH-LAST-OF-TYPE
A:NOT
A:FIRST-CHILD
A:LAST-CHILD

...
```

  [样式属性]
    1.基本常用的
      border-radius
      box-shadow
      text-shadow

```
2.背景的
  background -color / -image / -position / -repeat / -attachment / ...

  background-size：
       100px 100px  宽高具体值
       100% 100%  宽高百分比（相对于所在容器）
       cover  以合适的比例把图片进行缩放(不会变形)，用来覆盖整个容器
       contain 背景图覆盖整个容器（但是会出现，如果一边碰到容器的边缘，则停止覆盖，导致部分区域是没有背景图的）
       ...

  background-clip: 背景图片裁切
      border-box
      padding-box
      content-box

  background-origin：设置背景图的起始点
      border-box
      padding-box
      content-box

  ...

  filter

3.CSS3动画和变形(2D/3D)

  //=>变形不是动画
  transform:
     translate(X|Y|Z)  位移
     scale 缩放
     rotate 旋转
     skew 倾斜
     matrix 矩阵(按照自己设定的矩阵公式实现变形)
  transform-style:preserve-3d 实现3D变形
  transform-origin：变形的起点

  //=>过渡动画
  transition:
     transition-property:all/width... 哪些属性样式发生改变执行过渡动画效果，默认ALL，所有样式属性改变都会执行这个过渡效果
     transition-duration:过渡动画的时间，我们一把都用秒，例如：.5s
     transition-timing-function:动画运动的方式 linear(默认) ease ease-in ease-out ease-in-out cubic-bezier(执行自己设定的贝塞尔曲线)
     transition-delay:设置延迟的时间,默认是0s不延迟,立即执行动画
     ...

  //=>帧动画
  animation：
     animation-name 运动轨迹的名称
     animation-duration 运动的时长
     animation-timing-function 运动的方式(默认ease)
     animation-delay 延迟时间
     animation-iteration-count 运动次数(默认1  infinite无限次运动)
     animation-fill-mode 运动完成后的状态（帧动画完成后，元素会默认回到运动的起始位置，如果想让其停留在最后一帧的位置，设置这个属性值为forwards；backwards是当前帧动画如果有延迟时间，在延迟等待时间内，元素处于帧动画的第一帧位置；both是让帧动画同时具备forwards和backwards）
     ...

  //=>设置帧动画的运动轨迹
  @keyframes [运动轨迹名称] {
    from{
       //开始的样式
    }
    to{
       //结束的样式
    }
  }

  @keyframes [运动轨迹名称] {
     0%{
        //开始的样式
     }
     50%{}
     100%{
        //结束的样式
     }
  }

4.CSS3中的新盒子模型
  box-sizing: border-box / padding-box / content-box（默认值） 改变的就是我们在CSS中设置的WIDTH/HEIGHT到底代表啥  border-box让其代表整个盒子的宽高，当我们去修改PADDING或者BORDER，盒子大小不变，只会让内容缩放

  columns：多列布局

  flex：弹性盒子模型

5.一些其它的CSS3属性
  perspective:视距 实现3D动画必用的属性
  @media:媒体查询 实现响应式布局的一种方案
  @font-face:导入字体图标
  ...
```

### 三、响应式布局开发
   响应式布局：在不同尺寸的设备上都能良好的展示，这就是响应式布局设计（Responsive Layout）

   公司中的产品形态：
     1.PC端(全屏页面需要宽度自适应，但是一般都是固定宽度的)
     2.PC+移动端用同一套项目（简单的页面，例如：产品介绍，公司展示类的官网等）
     3.移动端（移动端设备尺寸差异较大，需要做响应式布局开发）
       嵌入到APP中的H5
       微信中分享出来的H5
       微信公号
       小程序
       靠浏览器访问的H5
       ...
     4.RN(React Native) / ionic / cordova ... JS开发APP的框架，使用JS代码开发APP，最后框架会把代码转换为 安卓和IOS 需要的代码

   如何实现响应式布局开发?
     最常用的方案：REM等比缩放响应式布局

```
 做移动端H5开发，首先加META标签
    <!--meta:vp [Tab]-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    REM和PX一样都是样式单位，PX是固定单位，REM是相对单位（相对于当前页面根元素HTML的字体设定的单位）

    我们开始给HTML的字体大小设置为100PX(1REM=100PX)，接下来我们写样式的时候，把所有的尺寸都用REM设定（测量出来的PX值/100就是应该设置的REM的值）,如果HTML的FONT-SIZE不变，用REM和PX一样，但是如果字体大小改变，也就是改变了REM和PX之间的换换算比例，那么之前所有用REM做单位的样式都会自动按照最新的比例进行缩放（实现了改动HTML的FONT-SIZE，整个页面中的元素都跟着缩放了，牵一发而动全身）

    真实项目中，设计师给给我们一套设计稿（常用的尺寸：640*1136  750*1334 640*960 ...），拿到设计稿后，我们严格按照设计稿中的尺寸去编写样式
       HTML{
          FONT-SIZE:100PX;
       }
       接下来写样式，把测量出来的PX都除以100变为REM，所有的单位基于REM来搞
       =>假设设计稿是750,也就相当于750的设备下,1REM=100PX

    我们页面运行在320的设备上，我们需要修改HTML的字体大小，以此实现页面跟着整体缩放：320/750*100 =>当前设备上HTML的字体大小
```



### 四、微信二次开发（小程序） =>Hybrid混合APP开发

​	Hybrid混合APP开发

1.前端做的都是H5页面  WebApp
  ->运行在浏览器中
  ->移动端不仅可以运行在浏览器中，还可以运行在 APP 中（例如：微信、自己公司的APP中）

  [优点]
    及时更新（不需要用户选择，我们只需要把服务器上的源文件更新，用户访问的永远是最新的）
    跨平台

  [弊端]
    不是直接运行在操作系统中的吗，是运行在浏览器或者APP中的，所以不能直接的操作手机上的软硬件（运作模式：H5通知浏览器或者APP我们想做什么 -> 浏览器调取手机的软硬件 ->浏览器把信息返回给H5）
    性能没有APP好
    ...

2.APP不是H5，它是原生的应用 NativeApp
  ->IOS: object-c / swift  (需要C的功底)
  ->安卓：java-native   (需要JAVA功底)

 [优点]
   用户把安装包下载到手机上进行安装，后期程序是直接运行在手机操作系统中的
     A:性能高
     B:可以调取手机内置的软件或者硬件（例如：调取摄像头、重力感应器、通讯录等）[前提用户需要同意才可以]

 [弊端]
   不能跨平台，一款产品需要两个团队开发两套不同的安装包
     A:成本大
     B:版本不统一
   不能及时更新
   苹果商店上传一款APP需要7天审核周期

3.Hybrid混合开发模式
  把传统IOS和安卓开发与H5开发结合在一起来做（微信公众号开发：把我们做的H5运行在微信APP中）

4.ReactNative ionic 微信小程序 ...



### 五、移动端事件

### 六、移动端常用的插件、类库、框架等

