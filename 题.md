**document.parentNode和document.parentnode有什么区别？**
第一个是document中本身就有的属性，值为null，第二个是document中没有的属性，值为undefined。

**如何规避多人开发函数重名的问题？**
基于单例模式实现模块开发，把实现当前模块的属性和功能放在一个同一个命名空间下

**你理解的闭包作用是什么，优缺点？**

当内部函数 在定义它的作用域 的外部 被引用时,就创建了该内部函数的闭包 ,如果内部函数引用了位于外部函数的变量,当外部函数调用完毕后,这些变量在内存不会被 释放,因为闭包需要它们

优点：

1.可以读取到其他函数内部的变量 
2.可以将变量保存在内存中 

缺点：

1.闭包会导致原有作用域链不释放，造成内存泄漏（内存占用）

**`代码题`**

```javascript
var n=0,
    fn=function(){
        this.n*=2;
        n++;
        return function(m){
            n+=++m;
            console.log(n);
        }
    };
var f=fn(2);
f(3);  //5
fn(3)(4);//16
f(4);//21
console.log(n);//21
------------------------------------------------------------------let i=2;
let fn=function(n){
        i *=2;
        return function(m){
        	i-= (n--)+(++m);
            console.log(i);
        }
    };
let f=fn(1);
f(2);//0
fn(3)(4);//-8
f(5);//-14
console.log(i);//-14
------------------------------------------------------------------
let n=1;
let x={
    n:2;
    y:(function(n){ //n=undefined
        n=n||3; //n=3
        return function(m){
            m=m||4;
            this.n+=m++;
            n+=++m;
            console.log(n);
        }
    })(window.n) //把window属性下的n传给函数，但是此时window下没有n，所以是undefined
};
let z=x.y;
x.y(5); //10  this：x/
z(6); //18
console.log(n,x.n);//1  7
------------------------------------------------------------------
let a={n:4};
let b=a;
b.x=a={n:10};//b.x给b添加新的属性，a给a重新定向到新的堆内存
console.log(a.x); //undefined
console.log(b.x); //{n:10}
------------------------------------------------------------------
function C1(name) {
	if (name) this.name = name; //if不成立，没有给实例设置私有属性
}
function C2(name) {
	this.name = name;//给实例设置私有属性，undefined
}
function C3(name) {
	this.name = name || 'join'; //给实例设置属性join
}
C1.prototype.name = "Tom";
C2.prototype.name = "Tom";
C3.prototype.name = "Tom";
alert(new C1().name + new C2().name + new C3().name);//tomundefinedjoin
------------------------------------------------------------------
let a=0,
	b=0;
function A(a){
	A=function(b){ //第一次执行到此处将A指向了里面的这个function，第二次调用A时，直接调用里面的这个函数。
		alert(a+b++);
	};
	alert(a++);
}
A(1);//1
A(2);//4 
```

**写出你熟知的ES6新语法**

- let/const
    - 不存在变量提升机制（变量不允许在声明之前使用）
    - let不允许重复声明
    - 在全局中基于let声明的变量和window的不是一个属性，和他没关系
    - typeof 未被声明的变量   =>不是undefined而是报错（暂时性死区）
    - let会形成块级作用域（类似私有作用域，大部分大括号也会形成块级作用域）

- 解构赋值
- “...”拓展，剩余，展开运算符
- 箭头函数
    - 没有arguments，但是可以基于 ...arg获取实参集合（结果是一个数组）
    - 没有自己的this，箭头函数中的this是上下文的this
- ES6中的模板字符串
- promise（async/await）
- class（ES6创建类的）
- interator（for of 循环）
- map/set
- ...................

**重排和重绘的读写分离**

思路：

​	1.首先什么是重排和重绘

​	2.突出他们消耗性能

​	3.突出自己写项目的时候注重了这些事情，以及自己解决的一些方案

浏览器渲染一个项目的时候是先按照“先创建DOM树 -> 在加载CSS -> 生成渲染树RENDER TREE -> 把渲染树交给浏览器（GPU）进行绘制”，如果后期我们修改了元素的样式（但是没有修改大小和位置），浏览器会把当前元素生成渲染树，然后重新渲染，这个机制是重绘，但是一旦元素的位置和大小发生改变，浏览器就要重新计算渲染，这个机制是回流（重排），不论是重排还是重绘都非常的消耗性能

在我以前的项目中，我特意的重视了这个问题，尽量减少操作DOM引发的回流和重绘的问题，常用的解决方案是：

​	1.需要动态的向页面追加元素的时候，基于文档碎片或者先把需要增加的所有元素拼接成字符串，最后统一进行增加

​	2.读写分离：把统一修改样式都存放到一起执行，新版的浏览器都有自己的监测机制，如果发现下面紧挨着的操作也是修改元素的样式，会把所有修改的事先存起来，直到遇到非修改样式的操作，会把之前存储的统一执行，引发一次回流和重绘

我认为这是比较重要的两种减少回流的方式。

**用户昵称规定只能是“数字，大小写字母”组成并且不能少于2位，不能多于20位，写出这个正则表达式**

```javascript
reg='/^[0-9a-zA-Z]{2,20}$/'
```

**谈谈你对面向对象的理解**

面向对象语言（Object-Oriented Language）是一类以对象作为基本程序结构单位的程序设计语言，指用于描述的设计是以对象为核心，而对象是程序运行时刻的基本成分

一切都是类、**一切都是对象**

对象的基本特征：

​	1.封装：将一个个独立的功能设计成一个个独立的单元，形成一个有规划设计的整体，减小耦合，提高内聚，避免迁一发而动全身，方便对程序的修改

​	2.继承：继承发生在两个对象之间，继承对象可以肆意的使用被继承对象的一些属性，方法和函数等；使代码重用，减少碼量，间接减少维护成本

​	3.多态：不同场合做出不同相应，有着不同的特点，可以说是封装的一个实现·······

**代码题**

```javascript
var point = {
    x: 10,
    y: 20,
    moveTo: function (x, y) {
        //this:point
        var moveX = function (x) {
            //this.window
            this.x = x;
        }
        var moveY = function (y) {
            this.y = y;
        }
        moveX(x);
        moveY(y);
    }
};
point.moveTo(100,200);
console.log(point.x,point.y);//10 20
```

**代码题**

```javascript
function fun(){
    this.a=10;
    this.b=function(){
        alert(this.a);
    }
}
fun.prototype={		//原型重定向后construct会不在，需要自己创建
    b:function(){
        this.a=20;
        alert(this.a);
    },
    c:function(){
        this.a=30;	//my_fun
        alert(this.a)
    }
}
var my_fun=new fun();
my_fun.b(); 	//10
my_fun.c();		//30
```

**代码题**

```javascript
var n=2;
function a(){
    var n=3;
    function b(m){
        alert(++n+m);
    }
    b(4);
    return b;
}
var c=a(5); //8
c(6);//11
alert(n);//2
```

**谈一下你对作用域链和原型链的理解**

`私有作用域`：函数执行会创建一个私有作用域，形参和在当前私有作用域中声明的都是私有变量，当前的私有作用域有自我保护机制，私有变量和外界是没有关系的，但是私有作用域中遇到了一个非私有的变量，则会向他的上级去寻找，如果还不是上级作用域私有的，则继续向上寻找，一直找到window为止，这种变量一层层向上查找的机制就是“作用域链机制”

`原型链`：他也是一种查找机制，实例首先在自己的私有属性中进行属性查找，如果不是私有属性，基于\_\_proto\_\_向所属类的原型上进行查找，如果再找不到，则继续基于\_\_proto\_\_向上查找，一直找到Object.prototype为止

**实现数组去重的方法**

1.利用ES6的set去重

```javascript
function unique (arr) {
  return Array.from(new Set(arr))
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
 //[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {}, {}]
```

无法去除空对象。

2.利用for循环嵌套for循环,然后splice去重

```javascript
function unique(arr){            
        for(var i=0; i<arr.length; i++){
            for(var j=i+1; j<arr.length; j++){
                if(arr[i]==arr[j]){         //第一个等同于第二个，splice方法删除第二个
                    arr.splice(j,1);
                    j--;
                }
            }
        }
return arr;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
    console.log(unique(arr))
    //[1, "true", 15, false, undefined, NaN, NaN, "NaN", "a", {…}, {…}]     //NaN和{}没有去重，两个null直接消失了
```

3.利用indexOf去重

```javascript
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array = [];
    for (var i = 0; i < arr.length; i++) {
        if (array .indexOf(arr[i]) === -1) {
            array .push(arr[i])
        }
    }
    return array;
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
   // [1, "true", true, 15, false, undefined, null, NaN, NaN, "NaN", 0, "a", {…}, {…}]  //NaN、{}没有去重
```

创建一个新数组，利用for循环原数组判断新数组中是否存在，如果存在相同的值则跳过，没有则push进数组

4.利用sort()

```javascript
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return;
    }
    arr = arr.sort()
    var arrry= [arr[0]];
    for (var i = 1; i < arr.length; i++) {
        if (arr[i] !== arr[i-1]) {
            arrry.push(arr[i]);
        }
    }
    return arrry;
}
     var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
// [0, 1, 15, "NaN", NaN, NaN, {…}, {…}, "a", false, null, true, "true", undefined]  //NaN、{}没有去重
```

利用sort()排序方法，然后根据排序后的结果进行遍历及相邻元素比对

5.利用对象的属性不能相同的特点去重

```javascript
Array.prototype.myUnique=function(){
	//this:ary 我们需要操作的数组，如果不想改变原有的数组，则克隆一份，处理克隆的数组
	let _this=this.slice(0);
	//或者_this=[...this];也可以实现克隆
	let obj={};
	for(let i=0;i<_this.length;i++){
		let item=_this[i];
		if(typeof obj[item]!=='undefined'){
			//当前项在数组中已经存在，需要将它除掉
			// _this.splice(i,1);  后面项移位，会消耗性能
        	_this[i]=_this[_this.length-1]; //将最后一位的值付给当前项
       		 _this.length--;//去除最后一项
       		 i--;//继续判断当前位
        	 continue;
     	}
     	obj[item]=true;
	}
    obj=null;
    return _this;
};
let ary=[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
let uniqueAry =ary.myUnique();
console.log(uniqueAry);  //两个true，NaN被去除了
```

6.利用includes

```javascript
function unique(arr) {
    if (!Array.isArray(arr)) {
        console.log('type error!')
        return
    }
    var array =[];
    for(var i = 0; i < arr.length; i++) {
            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值
                    array.push(arr[i]);
              }
    }
    return array
}
var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
console.log(unique(arr))
```

7.利用hasOwnProperty

```javascript
function unique(arr) {
    var obj = {};
    return arr.filter(function(item, index, arr){
        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)
    })
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, NaN, "NaN", 0, "a", {…}]   //所有的都去重了
```

利用hasOwnProperty 判断是否存在对象属性

8.利用filter

```javascript
function unique(arr) {
  return arr.filter(function(item, index, arr) {
    //当前元素，在原始数组中的第一个索引==当前索引值，否则返回当前元素
    return arr.indexOf(item, 0) === index;
  });
}
    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
        console.log(unique(arr))
//[1, "true", true, 15, false, undefined, null, "NaN", 0, "a", {…}, {…}]
```

9.

```javascript
let ary=[1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];
let uniqueAry=[...new Set(ary)];
console.log(uniqueAry);
```

**常用的算法**

1.递归

​	运用递归实现数组扁平化

```javascript
let ary=[1,2,[3,4,[5,6,[7,8]],[9,10]]];
        let result=[];
        function fn(ary){
            if(ary.length===0) return;
            for(let i=0;i<ary.length;i++){
                let item=ary[i];
                if(typeof item==='object'){
                    fn(item);
                }else{
                    result.push(item);    
                }
            }
        }
        fn(ary);
        console.log(result);
```

2.去重

3.冒泡排序

4.插入排序

5.快速排序

6.时间复杂度

7.空间负责度

8.KMP

.....

**你所掌握的继承的方式，以及什么时候使用到了继承**

面向对象：类的继承封装和多态

​	[封装]

​		把实现一个功能的JS代码进行封装，主要目的：“低耦合高内聚”

​	[多态]

​		重载：方法名相同，参数的个数或者类型不同，此时名字相同的方法才叫做方法的重载（后台语言中的重载）

（JS中的重载是根据传递参数的不同实现不同的功能）

​		重写：子类重写父类的方法

​	[继承]

​		子类继承父类的属性和方法

​		1.原型继承：让子类的原型指向父类的实例。

​		2.call继承：把父类A作为普通函数执行，让A中的THIS变为B的实例，相当于给B的实例增加一些属性和方法（弊端：把父类A当做普通函数执行，和父类原型没啥关系了，仅仅是把A中的私有属性变为子类B实例的私有属性而已，A原型上的共有属性方法和B及它的实例没啥关系）

​		3.寄生组合继承：A的私有变为B的私有，A的共有变为B的共有

​			object.creat:内置object类天生自带方法

​				1.创建一个空对象

​				2.让创建的空对象的\_\_proto\_\_指向第一个传进来的对象（把obj作为新创建空对象的原型）

​		4.ES6中class类实现继承

​		....

### JavaScript （前端玩家必备技能）

1. ele.getAttribute('propName') 和 ele.propName区别
2. mouseover和mouseenter的区别
3. 什么是事件代理
4. localStorage和cookie的区别，cookie和session的关系！
5. 什么是闭包，你在项目中哪一块用到了闭包！
6. js中定义函数的方式有哪些，区别是什么！
7. 说出你掌握的继承方式及优缺点，并加以改进！
8. 说出ES6和ES5的区别！
9. 阐述JS中的同步编程和异步编程，以及你在项目中是如何来使用异步操作的！
10. 实现一个Promise

### HTTP && AJAX && 跨域 （18+玩家必备技能，初级玩家需要了解一些的）

1. 写出项目中经常用到的性能优化方案
2. 从浏览器地址栏输入URL到显示页面，中间都经历了什么（尽可能写详细，最好回答出TCP的三次握手和四次挥手，以及浏览器加载页面的细节）
3. 说出你所熟知的HTTP状态码！GET和POST有啥区别！
4. 什么是HTTP报文，你熟知的报文都有哪些！
5. 能说下304具体怎样实现吗？
6. 跨域是什么？http协议中如何判断跨域？如何解决跨域问题？
7. HTTP2具体内容？SDPY了解么？
8. HTTPS如何实现？tsl/ssl是什么？对称加密、非对称加密在什么时候、对什么数据加密？
9. DNS劫持是什么？
10. 封装一个AJAX库！

**页面导入样式时，使用link和@import有什么区别？**

区别：

- 首先link是HTML标签，而@import是css提供的
- link引入的样式页面加载时同时加载，@import引入的样式需要等到页面加载完成的时候加载
- link没有兼容性的问题，@import不兼容ie5以下
- link可以通过JS操作dom动态引入样式表改变样式，而@import不可以









